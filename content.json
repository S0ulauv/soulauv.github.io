{"meta":{"title":"Soulauv's Blog","subtitle":"","description":"BE YOUR HERO","author":"Soulauv","url":"https://www.soulauv.cn","root":"/"},"pages":[{"title":"标签","date":"2019-11-17T09:19:45.000Z","updated":"2019-11-17T09:20:17.945Z","comments":true,"path":"tags/index.html","permalink":"https://www.soulauv.cn/tags/index.html","excerpt":"","text":""},{"title":"分类","date":"2019-11-17T09:17:24.000Z","updated":"2019-11-17T09:18:17.067Z","comments":true,"path":"categories/index.html","permalink":"https://www.soulauv.cn/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"Java 学习笔记(三)","slug":"Java-学习笔记-三","date":"2020-01-21T01:17:51.000Z","updated":"2020-01-21T02:43:01.476Z","comments":true,"path":"2020/01/21/Java-学习笔记-三/","link":"","permalink":"https://www.soulauv.cn/2020/01/21/Java-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%B8%89/","excerpt":"面向对象编程如何理解？在学习的过程中，偶然间看到知乎上一个转载片段讲的很生动形象，面向过程编程就像是做一盘蛋炒饭，需要把每一个步骤单独开来，比如煮米饭、炒鸡蛋、混合…… 最后的步骤是把炒好的鸡蛋和大米混合在一起。而面向对象编程( Object Oriented Programming )则不同，类比于盖浇饭，分别做好饭和盖菜，最后想要什么样的盖浇饭就在米饭上面盖什么样的盖菜。","text":"面向对象编程如何理解？在学习的过程中，偶然间看到知乎上一个转载片段讲的很生动形象，面向过程编程就像是做一盘蛋炒饭，需要把每一个步骤单独开来，比如煮米饭、炒鸡蛋、混合…… 最后的步骤是把炒好的鸡蛋和大米混合在一起。而面向对象编程( Object Oriented Programming )则不同，类比于盖浇饭，分别做好饭和盖菜，最后想要什么样的盖浇饭就在米饭上面盖什么样的盖菜。 类和实例类(class)实例(instance)类就像是一个煎鸡蛋的模子，而实例是用这个模子煎出来的一个一个的鸡蛋类比于类就是一个大类别，而实例是这个大类别的具体体现，如：类：岛国女演员实例：波多野结衣、饭岛爱、苍井空 定义类123456//类的定义类似于一种数据结构class Person &#123; public String name;//该类定义了两个字段 (field)分别为 name(String类型), age(int类型) public int age;//public 的意思是该字段可被外部访问&#125;//通过 class 把一组数据汇聚到一个类上实现了数据封装 定义实例1234Person Ming = new Person();//定义一个新的实例，变量名为 Ming,是 Person 类的变量Ming.name = \"XiaoMing\";//为 Ming 的 name 字段赋值为 \"XiaoMing\"Ming.age = 16;//为 Ming 的 age 字段赋值为 16System.out.println(Ming.name);//打印 Ming 的 name 字段 方法口语化简述首先，方法存在的意义：如果 class 都定义为 public 类型的话不安全，所以需要定义为 private 类型，然而这样外部就不能访问 private 类型的 field,于是需要引入方法(method)从外部访问 private field。","categories":[],"tags":[]},{"title":"排序算法","slug":"排序算法","date":"2020-01-17T12:08:08.000Z","updated":"2020-01-20T15:37:18.097Z","comments":true,"path":"2020/01/17/排序算法/","link":"","permalink":"https://www.soulauv.cn/2020/01/17/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/","excerpt":"大学的最后一个寒假了，希望自己能够持续学习，每天定一些小目标然后完成。","text":"大学的最后一个寒假了，希望自己能够持续学习，每天定一些小目标然后完成。 冒泡排序口语化简述给定一组指定的数，大小顺序不确定。首先比较num(0)和num(1)，若num(0) &lt; num(1)则两者相对位置不变，否则两者交换位置；接着比较num(1)与num(2)……每一轮循环结束，总有一个数在理想的位置，即在每次比较的最后面。冒泡排序可以形象化为有一个泡泡在一直咕噜咕噜着往后走。冒泡排序的时间复杂度是O(n^2)，在数组有序时为O(n) 算法实现1234567891011121314151617181920//冒泡排序算法import java.util.Arrays;public class bubble_sort&#123;public static void bubble_sort1(int[] arr) &#123;//此处定义了一个形参数组名字叫做arr(数组英文-array) int i , j , temp , len = arr.length;//变量i，j分别表示num(0)和num(n+1),temp为临时变量 for(i = 0; i &lt; len - 1; i++) for(j = 0; j &lt; len - 1; j++)//两个for循环。实话也很轻易看出时间复杂度是O(n^2) if (arr[j] &gt; arr[j+1])&#123; temp = arr[j]; arr[j] = arr[j+1]; arr[j+1] = temp; &#125;&#125;public static void main (String[] args)&#123;int [] array1 = &#123;12,43,23,2,5,54,67,45&#125;;bubble_sort1(array1);System.out.println(Arrays.toString(array1));&#125;&#125; 算法优化增加标志变量change123456789101112//增加标志变量change的目的是为了若检测到没有位置交换则序列已然有序，终止排序void buuble_sort(int arr[], int len)&#123; int i, j, change = 1; for (i = 0;i&lt;len - 1 &amp;&amp; change != 0; i++)&#123; change = 0; for (j = 0; j &lt; len - 1 - i; j++) if(arr[j]&gt;arr[j+1])&#123; swap(arr[j],arr[j+1]); change = 1; &#125; &#125;&#125; 鸡尾酒排序12345678910111213141516171819202122232425262728293031//鸡尾酒排序import java.util.Arrays;public class CockTail_Sort&#123; public static void cocktail_sort (int [] arr)&#123; int i ; int left = 0 ; int right = arr.length - 1; int temp; while (left &lt; right)&#123; for (i = left; i &lt; right; i++) if(arr[i] &gt; arr[i+1])&#123; temp = arr[i]; arr[i] = arr[i+1]; arr[i+1] = temp; &#125; right--; for(i = right; i &gt; left; i--) if(arr[i-1] &gt; arr[i])&#123; temp = arr[i]; arr[i] = arr[i-1]; arr[i-1] = temp; &#125; left++; &#125; &#125;public static void main (String[] args)&#123;int [] array1 = &#123;12,43,23,2,5,54,67,45&#125;;cocktail_sort(array1);System.out.println(Arrays.toString(array1));&#125;&#125; 插入排序口语化简述插入排序类似于我们玩扑克牌时的排序方式，及将新抽到的牌插入已经有序的牌组中将第一个元素标记为已排序，从第二个元素开始，与前一个元素比较，若小于前一个元素则将前一个元素后移一位，直至不小于前一个元素，此时插入抽出的元素 算法实现1234567891011121314151617181920import java.util.Arrays;//调用java标准库的内容public class Insertion_Sort&#123; public static void insertionSort(int [] arr)&#123; for (int i = 1; i &lt; arr.length; i++)&#123; int key = arr[i]; int j = i - 1; while (j &gt;= 0 &amp;&amp; arr[j] &gt; key)&#123; arr[j+1] = arr[j]; j--; &#125; arr[j+1] = key; &#125; &#125;public static void main (String[] args)&#123;int [] array1 = &#123;12,43,23,2,5,54,67,45&#125;;insertionSort(array1);System.out.println(Arrays.toString(array1));&#125;&#125;//无论是哪种排序方法，都只是一个函数而已，需要自己构建一个使用函数的环境。","categories":[],"tags":[]},{"title":"Java 学习笔记(二)","slug":"Java-学习笔记-二","date":"2020-01-16T07:37:45.000Z","updated":"2020-01-20T15:37:15.136Z","comments":true,"path":"2020/01/16/Java-学习笔记-二/","link":"","permalink":"https://www.soulauv.cn/2020/01/16/Java-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%BA%8C/","excerpt":"遍历数组操作通过 for 循环遍历数组123456789public class main &#123; public static void main(String[] args)&#123; int [] ns = &#123;1,4,9,16,25&#125;; for (int i = 0; i &lt; ns.length;i++&gt;)&#123; int n = ns[i]; System.out.println(n); &#125;//该方法变量n拿到的是元素在数组中的索引 &#125;&#125;","text":"遍历数组操作通过 for 循环遍历数组123456789public class main &#123; public static void main(String[] args)&#123; int [] ns = &#123;1,4,9,16,25&#125;; for (int i = 0; i &lt; ns.length;i++&gt;)&#123; int n = ns[i]; System.out.println(n); &#125;//该方法变量n拿到的是元素在数组中的索引 &#125;&#125; 通过 for each 循环遍历数组12345678public class main &#123; public static void main(String[] args)&#123; int [] ns = &#123;1,4,9,16,25&#125;; for (int n : ns)&#123; System.out.println(n); &#125;//该方法变量n拿到的直接为数组中的元素 &#125;&#125; Arrays.toString()方法1234567import java.util.Arrays;//导入工具public class main &#123; public static void main(String[] args)&#123; int[] ns = &#123;1,2,4,9,16&#125;; System.out.println(Arrays.toString(ns)); &#125;&#125; 数组排序调用 Java 内置的排序功能12345678910111213141516171819import java.util.Arrays;public class main &#123; public static void main(String[] args)&#123; int[] ns = &#123; 28, 12, 43, 53, 67, 26&#125;; Arrays.sort(ns); System.out.println(Array.toString(ns));//这种排序方式修改了数组本身 &#125;&#125;``` ## 多维数组### 二维数组```java//定义一个二维数组int [][] ns = &#123; &#123;1, 2, 3, 4&#125;, &#123;5, 6, 7, 8&#125;, &#123;9, 10, 11, 12&#125;&#125;; 二维数组的结构二维数组本质上是数组的嵌套其结构如下： 访问二维数组的某个元素12//array[row][col] 此法来访问二维数组的某个元素 row即为行，col即为列。System.out.println(ns[1][2]); 打印一个二维数组需要使用两层嵌套的for循环 12345678//二维数组也可理解为\"二重数组\"即一个嵌套一个for (int[] arr : ns)&#123; for (int n : arr)&#123; System.out.print(n); System.out.print(','); &#125; System.out.println();&#125; 使用 Java 标准库的方法1234567891011import java.util.Arrays;public class main &#123; public static void main(String[] args)&#123; int[][] ns = &#123; &#123;1, 2, 3, 4&#125;; &#123;5, 6, 7, 8&#125;; &#123;9, 10, 11, 12&#125;//二维数组的最后一行不需要加分号\";\" &#125;; System.out.println(Arrays.deepToString(ns));&#125;&#125; 三维数组二维数组的结构二维数组的本质上是二维数组再嵌套一个数组。结构如下： 访问三维数组的某个元素1ns[2][0][1]; 命令行参数口语化简述在命令行中可以执行java程序，在执行的同时可以传递一个参数，该参数为一个String[]数组(main方法可以接受一个命令行参数) 1234567public class main&#123; public static void main(String[] args)&#123; for (String arg : args)&#123; System.out.println(arg); &#125; &#125;&#125; 例如打印版本号 1234567891011public class main&#123; public static void main(String[] args)&#123; for (String arg : args)&#123; if (\"-version\".equals(arg))&#123; System.out.println(\"v 1.00\"); break; &#125; &#125; &#125;&#125;以上程序需要在命令行编译并执行","categories":[],"tags":[]},{"title":"Windows环境下搭建hexo框架博客","slug":"Windows环境下搭建hexo框架博客","date":"2020-01-16T06:14:08.953Z","updated":"2020-01-16T06:43:53.469Z","comments":true,"path":"2020/01/16/Windows环境下搭建hexo框架博客/","link":"","permalink":"https://www.soulauv.cn/2020/01/16/Windows%E7%8E%AF%E5%A2%83%E4%B8%8B%E6%90%AD%E5%BB%BAhexo%E6%A1%86%E6%9E%B6%E5%8D%9A%E5%AE%A2/","excerpt":"Windows10下搭建hexo博客安装Git 进入Git官网,或直接点击此处开始下载 全部默认安装 安装完成后会在开始菜单出现","text":"Windows10下搭建hexo博客安装Git 进入Git官网,或直接点击此处开始下载 全部默认安装 安装完成后会在开始菜单出现 安装nodejs 进入nodejs中文网，或点击此处下载64位安装包 全部默认安装 打开上一步图片中的Git Bash，输入 12node -vnpm -v 查看nodejs是否安装成功若结果出现 ]则安装成功 全局安装cnpm 在Git Bash下输入 1npm install -g cnpm --registry=https://registry.npm.taobao.org 等待安装完成 输入1cnpm -v 若出现版本号则安装成功 安装hexo框架 输入1cnpm install -g hexo-cli 进行安装 输入1hexo -v 若出现版本号则安装成功 初始化hexo博客 在某一位置(如在D盘根目录下)新建一文件夹(如命名为 hexo) 右键打开Git Bash输入 1hexo init 此时文件夹中出现以下内容 启动博客输入 1hexo s 出现 将’’http://localhost:4000&quot;输入浏览器网址框中即可在本地访问 输入”Crtl + C”断开 将hexo博客部署到Github上 创建自己的Github账号后在页面右上角点击New repository新建一个仓库 按照下图格式进行命名 最好和用户名相同 在hexo目录下安装deployer插件 1cnpm install --save hexo-deployer-git 设置_config.yml 文件输入 1vim _config.yml 在文件最底部内容按图进行配置 启动第二项 repo 为你的GitHub仓库地址位置如下图所示，复制粘贴即可 输入 1hexo d 大功告成","categories":[],"tags":[]},{"title":"Java 学习笔记(一)","slug":"Java-学习笔记-一","date":"2019-12-03T07:25:38.000Z","updated":"2020-01-22T01:52:04.340Z","comments":true,"path":"2019/12/03/Java-学习笔记-一/","link":"","permalink":"https://www.soulauv.cn/2019/12/03/Java-%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-%E4%B8%80/","excerpt":"JDK JRE JVM 的关系 JVM(Java Virtual Machine)即Java虚拟机,Java技术的核心,与Java最重要的跨平台特性息息相关 JDK(Java Development Kit)即Java开发工具包 JRE(Java Runtime Environment)即Java运行环境","text":"JDK JRE JVM 的关系 JVM(Java Virtual Machine)即Java虚拟机,Java技术的核心,与Java最重要的跨平台特性息息相关 JDK(Java Development Kit)即Java开发工具包 JRE(Java Runtime Environment)即Java运行环境 Hello World12345public class HelloWorld&#123; public static void main(String[] args)&#123; System.out.println(\"HelloWorld\"); &#125;&#125; 变量定义变量 1int a = 1 //数据类型 变量名称 常量final 关键字声明常量属性 1final double PI = 3.14; //声明一个名为PI的常量并赋值为3.14 数据类型 数据类型 默认值 存储格式 数据范围 包装类型 short 0 2B -32,768 ~ 32,767 Short int 0 4B -2,147,483,648 ~ 2,147,483,647 Integer byte 0 1B -128 ~ 127 Byte char 空 2B 0 ~ 65535 Character long 0L或0l 8B -9,223,372,036,854,775,808 ~ 9,223,372,036,854,775,807 Long float 0.0F或0.0f 4B 32位IEEE-754单精度范围 Float double 0.0或0.0D(d) 8B 64位IEEE-754双精度范围 Double boolean false 1B true 或 false Boolean 整数byte, short. int, long 1long num = 1L; 浮点数float, double 1float num = 7.2F //double 类型可以不加d charchar 表示单个字符 1char a = 'a'; boolean仅有true 或者 false 字符串 初始化12String s0 = \"abc\";String s1 = new String(\"abc\"); 计算字符串的长度12345678//length 方法public int length()&#123;&#125;//调用方法String s1 = \"abc\";String s2 = \"Java\";int len1 = s1.length();int len2 = s2.length(); 字符串比较equals() 方法: 判断两个字符串对象的内容是否相同( 同则返回true; 不同则返回false )equalsIgnoreCase()方法: 忽略大小写concat()方法: 连接字符串charAt()方法: 按照索引值, 获得字符串中的指定字符123456789101112public class StringCompare &#123; public static void main(String[] args)&#123; String s = new String(\"Java\");//定义字符串方法1,定义s并初始化为Java String m = \"java\";//定义字符串2,定义m并初始化为java System.out.println(s.equals(m));//不忽略大小写 System.out.println(s.equalsIgnoreCase(m));//忽略大小写 System.out.println(s == m);//比较内存地址是否相同 System.out.println(\"Hello\" + \"java\");//字符串连接方法1 System.out.println(s.concat(m));//字符串连接方法2concat()方法 System.out.println(s.charAt(1));//输出字符串中索引值为1的字符 &#125;&#125; 字符串常用提取方法 方法 返回值 功能描述 indexOf(int ch) int 搜索字符 ch 第一次出现的索引 indexOf(String value) int 搜索字符串 value 第一次出现的索引 lastIndexOf(int ch) int 搜索字符串 ch 最后一次出现的索引 LastIndexOf(String value) int 搜索字符串 value 最后一次出现的索引 substring(int index) String 提取从索引开始到结束的字符串 substring(int beginindex, int endindex) String 提取 beginindex 和 endindex 之间的字符串部分 trim() String 返回一个前后不含任何空格的调用字符串的副本 算术运算符 算术运算符 名称 描述 类型 举例 + 加法 相加运算符两侧的值 双目运算符 a + b = 8 - 减法 左操作数减去右操作数 双目运算符 a - b = 2 * 乘法 相乘操作符两侧的值 双目运算符 a * b = 15 / 除法 左操作数除以右操作数 双目运算符 a / b = 1 % 取余 左操作数除以右操作数的余数 双目运算符 a % b = 2 ++ 自增 操作数的值增加1 单目运算符 ++i = 2 – 自减 操作数的值减少1 单目运算符 –i = 0 ++i, –i: 先自增或自减,再进行表达式运算 i++, –i: 先进行表达式运算,再自增或自减 位运算符表格中a = 60, b = 13 位运算符 名称 描述 举例 &amp; 按位与 同 1 则 1, 否则为 0 (a &amp; b), 得到 12, 即 0000 1100 | 按位或 同 0 则 0, 否则为 1 (a ^ 按位异或 同 0 异 1 (a ^ b), 得到 49, 即 0011 0001 ~ 按位补 翻转操作数的每一位 (~a), 得到 -61, 即 1100 0011 &lt;&lt; 按位左移 左操作数按位左移右操作数指定的位数 a &gt;&gt; 2 得到240, 即 1111 0000 &gt;&gt; 按位右移 左操作数按位右移右操作数指定的位数 a &lt;&lt; 2 得到 15, 即 1111 &gt;&gt;&gt; 按位右移补零 左操作数的值按右操作数指定的位数右移, 空位补零 a &gt;&gt;&gt; 2 得到 15, 即 0000 1111 逻辑运算符表格中 a = true, b = false 逻辑运算符 名称 描述 类型 举例 &amp;&amp; 与 同真则真, 否则为假 双目运算符 (a &amp;&amp; b) 为假 || 或 有真就真, 有假必假 双目运算符 (a ! 非 非真为假, 非假为真 单目运算符 (!a) 为假 ^ 异或 同则假, 否则为真 双目运算符 (a ^ b) 为真 比较运算符 比较运算符 名称 == 等于 ! = 不等于 &gt; 大于 &lt; 小于 &gt;= 大于等于 &lt;= 小于等于 双目运算符: 布尔表达式? 表达式 1 : 表达式 2如果布尔表达式的值为true 则执行表达式1, 否则执行表达式2 ==和!=适用于所有的基本数据类型，其他关系运算符不适用于boolean，因为 boolean 值只有true和false，比较没有任何意义。 ==和!=也适用于所有对象，可以比较对象的引用是否相同。 方法(函数)123访问修饰符 返回值类型 方法名(参数列表)&#123; 方法体&#125; 如 123public void functionName(Object arg)&#123; 方法体&#125; if 语句if 语句 123if(条件)&#123; 条件成立时执行的代码&#125; if else 语句 123456if(条件)&#123; 代码块1&#125;else&#123; 代码块2&#125; 多重 if 语句 12345678910if(条件1)&#123; 代码块1&#125;else if(条件2)&#123; 代码块2&#125;...else&#123; 代码块n&#125; switch 语句1234567891011switch(表达式)&#123; case 值1: 代码块1 break; case 值2: 代码块2 break; ... dafult: 默认执行的代码块&#125; while 语法先判断, 在执行 123while(条件)&#123; 代码块&#125; do-while 语法先执行, 再判断 123do&#123; 代码块&#125;while(条件); for 语句123for(循环变量初始化; 循环条件; 循环变量变化)&#123; 循环操作&#125; 跳转语句break: 用于条件和循环语句中, 用来跳出循环语句continue: 跳过循环体中剩余的语句执行下一次循环 数组相同数据类型的元素按一定顺序排列的集合。 12345678910111213141516171819202122232425262728293031323334//声明数组数据类型[] 数组名;//或者： 数据类型 数组名[]//例子int args[];char symbol[];String [] name;//定义数组数组名 = new 数据类型 [数组长度];//例子int [] ages = &#123;12, 18, 9, 33, 45&#125;;char [] symbol = new char[10];//通过下标访问数组元素ages[0] = 12;//将一个数组赋值给另一个数组int [] a1 = &#123;1, 2, 3&#125;;int [] a2;a2 = a1;//a1和a2是同一数组的不同名称//数组遍历int [] ages = &#123;12, 21, 2, 43, 23&#125;;for(int i = 0; i &lt; ages.length; i++)&#123; System.out.println(ages[i]);&#125;//foreach 方法int [] ages = &#123;12, 21, 2, 43, 23&#125;;int i = 1;for(int age:ages)&#123; System.out.println(age); i++;&#125; 二维数组12345678910111213141516//声明和定义数据类型 [] [] 数组名 = new 数据类型[行的个数][列的个数]；//或者数据类型 [] [] 数组名；数组名 = new 数据类型[行的个数][列的个数]；//或者数据类型 [] [] = 数组名 = &#123;&#123;第一行值1， 第一行值2, ...&#125;&#123;第二行值1， 第二行值2，...&#125;...&#125;//通过下标访问二维数组数组名[行的索引][列的索引] = 值;","categories":[],"tags":[]},{"title":"各类快捷键","slug":"各类快捷键","date":"2019-12-01T12:16:05.000Z","updated":"2019-12-03T16:17:15.531Z","comments":true,"path":"2019/12/01/各类快捷键/","link":"","permalink":"https://www.soulauv.cn/2019/12/01/%E5%90%84%E7%B1%BB%E5%BF%AB%E6%8D%B7%E9%94%AE/","excerpt":"VS code 常用快捷键 按键 作用 Ctrl + Shift + V 预览Markdown 文档 Ctrl + / 批量注释批量取消注释 Ctrl + k 接Ctrl + t 更换主题 Ctrl + Shift + P 打开命令行","text":"VS code 常用快捷键 按键 作用 Ctrl + Shift + V 预览Markdown 文档 Ctrl + / 批量注释批量取消注释 Ctrl + k 接Ctrl + t 更换主题 Ctrl + Shift + P 打开命令行 Markdown 常用操作 操作 目的 ![avatar](图片路径) 插入图片 ``` ``` 连续三个反引号间插入代码块 ```java ``` ```后键入所使用语言实现代码高亮 Linux 常用快捷键 命令 作用 全称 touch 创建新文件 Windows下常用快捷键 按键 作用 全称 Ctrl + Win + → 切换桌面 Win + V 打开剪切板 Tab 制表键 Tabulator key Ctrl + Shift + B 唤出Win10 表情输入界面","categories":[],"tags":[{"name":"VS code","slug":"VS-code","permalink":"https://www.soulauv.cn/tags/VS-code/"}]}]}